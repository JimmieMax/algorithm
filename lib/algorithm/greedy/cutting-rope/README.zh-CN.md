# 剪绳子

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n 都是整数，n>1 并且 m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]_k[1]_...\*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。

示例 1：

> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1

示例  2:

> 输入: 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

## 解法：贪心法

力扣上此题给出了提示：多试试几个例子，找出规律。下面说下我找规律的思路。

前面提到：8 拆分为 3+3+2，此时乘积是最大的。然后就推测出来一个整数，要拆成多个 2 和 3 的和，保证乘积最大。原理很容易理解，因为 2 和 3 可以合成任何数字，例如5=2+3，但是5 < 2*3；例如6=3+3，但是6<3*3。所以根据贪心算法，就尽量将原数拆成更多的 3，然后再拆成更多的 2，保证拆出来的整数的乘积结果最大。

但上面的解法还有不足。如果整数 n 的形式是 3k+1，例如 7。按照上面规则，会拆分成“3 + 3 + 1”。但是在乘法操作中，1 是没作用的。此时，应该将 1 和 3 变成 4，也就是“3 + 3 + 1”变成“3 + 4”。此时乘积最大。

综上所述，算法的整体思路是：

>- n 除 3 的结果为 a，余数是 b
>- 当 b 为 0，直接将 a 个 3 相乘
>- 当 b 为 1，将（a-1）个 3 相乘，再乘以 4
>- 当 b 为 2，将 a 个 3 相乘，再乘以 2
空间复杂度是 O(1)，时间复杂度是 O(1)。
